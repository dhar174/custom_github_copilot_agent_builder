---
title: AgentOps Framework Generator Architecture
version: 1.0
date_created: 2026-01-27
owner: Core Engineering
tags: [architecture, agentops, automation, github-actions, ai-agents, copilot, scaffolding, customization, governance, llm-integration]
---

# Introduction

This specification defines the system architecture for the **AgentOps Framework Generator**, a tool capable of analyzing any GitHub repository and automatically configuring it with a robust AgentOps environment. This includes custom agents, Copilot instructions, prompt skills, and governance documentation.

The system is delivered as a reusable GitHub Action workflow, enabling deterministic bootstrapping and maintenance of Copilot agent capabilities across an organization.

## 1. Purpose & Scope

The purpose of this specification is to detail the technical implementation of the [001-agentops-pack-applier](./agent_builder_first_intent.md) intent.

**Scope:**
- **Sensing Engine**: analyzing target repositories to build a deterministic snapshot.
- **Planning Engine**: using AI agents to determine the optimal configuration keying off the snapshot.
- **Packing Engine**: generating the file bundles and assets.
- **Application Engine**: applying changes safely using managed sections and idempotency checks.
- **Delivery Mechanism**: creating and updating Pull Requests.

**Audience:**
- Core Platform Developers
- Agent Engineers

## 2. Definitions

- **AgentOps Pack**: A bundled collection of configuration files (agents, instructions, prompts) that defines the "brain" of the Copilot workspace.
- **RepoSnapshot**: A deterministic JSON representation of a repository's structure and signals (languages, frameworks), used as input for planning.
- **PlanManifest**: A JSON document generated by the Planner Agent that prescribes what files should be created or updated.
- **Managed Section**: A designated block within a file that the automation is allowed to overwrite, ensuring human edits outside these blocks are preserved.
- **PackSource**: The source of truth for templates and assets used to generate the pack.

## 3. Requirements, Constraints & Guidelines

### Requirements

- **REQ-BOOT-001**: The system must provide a callable GitHub Action workflow (`.github/workflows/apply.yml`) that accepts a `token` and `inputs`.
- **REQ-SENSE-001**: The system must verify the repository structure and extract signals (e.g., `package.json`, `pyproject.toml`) deterministically (FR-1).
- **REQ-PLAN-001**: The system must utilize an AI Planner Agent to analyze the `RepoSnapshot` and generate a `PlanManifest` without hallucinating file paths (FR-2).
- **REQ-CONTENT-001**: The system must utilize AI agents to generate and refine relevant custom agents, instructions, specs, and prompts based on deep research, analysis, and understanding of the target repository's context.
- **REQ-APPLY-001**: The system must apply changes in one of three modes: `safe` (create only), `refresh` (update managed sections only), or `overwrite` (replace managed files).
- **REQ-GOV-001**: The system must generate governance files including `repo-profile.md` and `mcp.md` (FR-11).
- **REQ-DELIVERY-001**: The system must deliver changes via a Pull Request and never push directly to default branches (FR-10).

### Constraints

- **CON-ENV-001**: Must run on standard GitHub-hosted runners (`ubuntu-latest`) without requiring privileged Docker-in-Docker contexts (FR-0.2).
- **CON-PERM-001**: Must operate with minimal GitHub permissions, primarily `contents: write` and `pull-requests: write`.
- **CON-HARM-001**: Must never overwrite unmanaged human edits in files marked as partially managed.

### Guidelines

- **GUD-DX-001**: Generated PRs should have descriptive bodies explaining *why* changes were made.
- **GUD-ARCH-001**: Code should be modular, separated into `sense`, `plan`, `pack`, `apply`, and `pr` domains.

## 4. Interfaces & Data Contracts

### 4.1. Repo Snapshot (`sense`)

Used to capture the state of the target repository.

```typescript
export interface RepoSnapshot {
  repoName: string;
  defaultBranch: string;
  structure: DirectoryNode[];    // Folder structure (limited depth)
  signals: RepoSignals;          // Detected languages/frameworks
  aiConfig: ExistingAiConfig;    // Existing agent/copilot files
  conventions: ExistingConventions; // Existing docs/specs folders
}
```

### 4.2. Plan Manifest (`plan`)

The AI-generated prescription for the repository.

```typescript
export interface PlanManifest {
  repoProfile: {
    purpose: string;
    stack: string[];
    commands: Record<string, string>;
  };
  selection: {
    basePack: boolean;
    stackPacks: string[];  // e.g. ['node-typescript', 'react']
    components: string[];  // e.g. ['agents', 'instructions']
  };
  files: PlanFileAction[];
  managedPolicy: {
    marker: string;        // "<!-- agentops-managed: true -->"
    blockStart: string;    // "<!-- BEGIN: agentops-managed -->"
    blockEnd: string;      // "<!-- END: agentops-managed -->"
  };
}
```

### 4.3. Plan File Action (`plan`)

An atomic action for a single file.

```typescript
export interface PlanFileAction {
  path: string;
  action: 'create' | 'update' | 'delete' | 'ignore';
  reason: string;
  templateId?: string;
}
```

## 5. Acceptance Criteria

- **AC-001**: **Idempotency** - Re-running the tool on a repo with no changes since the last run result in a "No changes detected" outcome and no new/updated PR.
- **AC-002**: **Protection** - If a user adds text to `repo-profile.md` outside a managed block, a subsequent `refresh` run must preserve that text.
- **AC-003**: **Detection** - A Node.js repo is correctly identified as `stack: ['node', 'typescript']` and receives the TypeScript-specific instructions.
- **AC-004**: **Delivery** - A PR is successfully created with the correct branch name `agentops/apply-pack`.

## 6. Test Automation Strategy

- **Unit Testing**:
  - `src/sense`: Mock file system to verify signal detection logic.
  - `src/apply`: Test managed section replacement logic with various regex cases.
  - `src/plan`: Mock OpenAI responses to verify manifest parsing.
  - **Framework**: Vitest or Jest.

- **Integration Testing**:
  - "Dry Run" tests against the builder repo itself during CI.
  - Verification that generated Markdown is valid.

## 7. Rationale & Context

### Managed Sections
To avoid the "eject" problem common in scaffolding tools, we use **Managed Sections**. This approach allows the "Robot" (Automation) to own specific parts of a file (like the Tech Stack section of a Repo Profile) while the "Human" owns the Context or Business Logic sections. This enables continuous updates without overwriting manual context.

### Planner Agent
Static templates are often too rigid. By using a lightweight Planner Agent (LLM), we can tailor the `repo-profile.md` and select the right mix of instructions based on heuristic signals, providing a "high-touch" feel with automated reliability.

## 8. Dependencies & External Integrations

### External Libraries
- **@actions/core, @actions/github**: For interfacing with the GitHub Actions runner and API.
- **js-yaml**: For parsing/serializing YAML frontmatter in agent files.
- **openai**: For communicating with GitHub Models (or Azure OpenAI) for the Planning phase.

### GitHub Platform
- **GitHub Models**: Used as the inference engine for the Planner.
- **GitHub Actions**: The execution environment.

## 9. Examples & Edge Cases

### Managed Block Example
```markdown
# Repository Profile

<!-- BEGIN: agentops-managed -->
## Tech Stack
- Node.js
- TypeScript
<!-- END: agentops-managed -->

## Business Context
(This section is written by humans and preserved by the agent)
The goal of this project is...
```

### Edge Cases
- **Repo has no signals**: The Planner should default to a generic "Base Pack".
- **API Failure**: If the Planner Agent fails (e.g., rate limit), the system should fall back to a safe default configuration or fail gracefully without modifying files.
- **Branch Protection**: If the target branch is protected, the PR creation must utilize the appropriate token or fork strategy (though initially, we assume write access to the repo).

## 10. Validation Criteria

- **Linting**: Generated files must pass standard definition schema checks (e.g., proper YAML frontmatter in `.agent.md`).
- **Build**: The `apply` action itself must compile to a single JS file using `ncc` or `esbuild`.

## 11. Related Specifications / Further Reading

- [First Intent: AgentOps Pack Applier](./agent_builder_first_intent.md)
- [Managed Sections Implementation](./../memory-bank/bolts/bolt-pack-apply-engine-1/implementation-walkthrough.md)
